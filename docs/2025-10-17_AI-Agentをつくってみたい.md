# AI Agent Implementation Plan

## 現状の課題

現在の実装は「単発のLLM呼び出し」で、AI Agentとは程遠い:

```
ユーザー質問
  ↓
キーワード抽出（Claude API呼び出し1回目）
  ↓
Discord検索（1回だけ）
  ↓
回答生成（Claude API呼び出し2回目）
  ↓
終了
```

課題:
- 情報が不足していても追加で調査しない
- 検索結果が期待と違っても再試行しない
- 複雑な質問を分解して段階的に解決できない
- 自律的な判断ができない

## 目指す姿: Agentic Loop

Claude CodeやGemini CLIのように、自律的に情報を集めて回答するボット:

```
ユーザー質問
  ↓
┌─────────────────────────────┐
│ 思考: 何の情報が必要?         │
│ 判断: どのツールを使う?       │ ← Claudeが自律判断
│ 実行: ツール呼び出し          │
│ 観察: 結果を確認             │
│ 継続: まだ足りない?          │
└─────────────────────────────┘
  ↓ 十分な情報が集まるまでループ
✅ 回答生成
```

## 実装アプローチの検討

### 選択肢の概要

Agentを実装する方法として、以下の選択肢がある:

1. **既存CLIツールを包む** (Claude Code CLI / Gemini CLI)
2. **公式Agent SDKを使う** (Anthropic Claude Agent SDK)
3. **自前でAgentループを実装** (Anthropic API + 独自実装)

### ❌ 選択肢1: 既存CLIツールを包む

「Claude CodeやGemini CLIを動かして、そのインターフェイスにDiscordをかぶせる」アプローチ:

**Claude Codeの場合:**
- VSCode拡張機能として設計されている
- CLIモードも存在するが、インタラクティブな対話型で設計されている
- Discord用のカスタムツールを注入する仕組みがない
- サーバーサイドで複数リクエストを並列処理する用途には不向き

**Gemini CLIの場合:**
```ruby
# 理論上は可能だが...
response = `gemini chat "#{user_message}"`
```

問題点:
- プロセス起動のオーバーヘッド(毎リクエストでプロセス生成)
- セッション管理不可(毎回コンテキストリセット)
- Discord専用ツールを追加できない
- エラーハンドリング困難
- セキュリティリスク(コマンドインジェクション)
- インタラクティブなCLIツールをバッチ処理的に使うのは本来の用途と異なる

### 🤔 選択肢2: 公式Agent SDKを使う

AnthropicがPythonとTypeScript向けに提供している **Claude Agent SDK** を使うアプローチ:

- GitHub: [claude-agent-sdk-python](https://github.com/anthropics/claude-agent-sdk-python)
- GitHub: [claude-agent-sdk-typescript](https://github.com/anthropics/claude-agent-sdk-typescript)
- 公式ブログ: [Building agents with the Claude Agent SDK](https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk)

**主な機能:**
- `ClaudeSDKClient`: Claude Codeとの双方向インタラクティブな会話
- カスタムツール: Pythonの関数としてツールを定義可能(in-process MCP servers)
- フック機能: Agent loopの特定のタイミングで処理を挟める
- Claude Codeの既存Agent機能をラップ

**メリット:**
- 公式サポート、バグ修正やアップデートが期待できる
- Agent loopの実装が不要(Claude Codeの機能を利用)
- in-process MCP serverでツールをPython/TSで直接定義
- ドキュメントとサンプルコードが充実

**デメリット:**
- **言語の制約**: Python または TypeScript のみ(Rubyサポートなし)
- **Claude Codeへの依存**: Claude Codeのインストールと実行環境が必要
- **アーキテクチャの複雑化**: Rails(Ruby) → Python/Node.js → Claude Code の多層構造
- **デプロイの複雑化**: Railsアプリに加えてPython/Node.js環境の管理
- **オーバーヘッド**: Claude Codeプロセスを起動・管理する必要がある
- **カスタマイズの制約**: Claude Codeの枠組みの中での実装になる

**Rails統合の場合:**
```ruby
# RailsからPython SDKを呼び出す必要がある
class DiscordAgentResponseJob < ApplicationJob
  def perform(message)
    # 方法1: Python subprocessを起動
    result = `python3 agent_script.py "#{message}"`

    # 方法2: gRPC/HTTPでPythonサービスと通信
    response = AgentService.call(message)
  end
end
```

**判断:**
- RailsネイティブなプロジェクトでPython/TypeScriptを導入するのは、保守性の観点から慎重に検討すべき
- 小規模チームや学習目的のプロジェクトでは、依存関係を増やすより自前実装の方が理解しやすい
- ただし、大規模で複雑なAgent機能が必要な場合は検討の価値あり

### ⭐️ 選択肢3: 自前でAgentループ実装(推奨)

Claude CodeやGemini CLIと**同じ技術**を使って自作:

| 要素 | Claude Code | 自作実装 | 状況 |
|-----|------------|---------|------|
| LLM | Claude Sonnet 4.5 | Claude Sonnet 4.5 | ✅ 同じ |
| API | Anthropic Tool Use | Anthropic Tool Use | ✅ 同じ |
| ツール | ファイル操作等 | Discord操作 | ✅ より適切 |
| Agentループ | VSCode拡張内 | Ruby実装 | 🔨 実装必要 |
| 統合 | VSCode | Rails | ✅ ネイティブ |

**結論**: Claude Codeは「Anthropic APIの参考実装」に過ぎない。同じAPIを使えば同等の知能が得られる。

## 実装方針

### アーキテクチャ

```
Discord Message
  ↓
DiscordAgentResponseJob (Rails ActiveJob)
  ↓
Llm::AgentLoop (Agentループオーケストレーター)
  ↓
Llm::Claude (Anthropic SDK wrapper, ツール対応版)
  ↓
Discord::Tools::* (各種ツール実装)
  ├─ SearchMessages (Discord検索)
  ├─ GetChannelInfo (チャンネル情報)
  ├─ GetThreadContext (スレッド履歴)
  ├─ SearchWeb (外部検索)
  └─ AnalyzeReactions (リアクション分析)
```

### コア実装: Agentループ

```ruby
# app/services/llm/agent_loop.rb
module Llm
  class AgentLoop
    MAX_ITERATIONS = 10
    MAX_TOKENS_BUDGET = 50_000

    attr_reader :iterations, :total_tokens

    def initialize(claude_client)
      @claude = claude_client
      @tools = load_tools
      @iterations = 0
      @total_tokens = 0
    end

    def run(user_message:, system_prompt:)
      messages = [{ role: "user", content: user_message }]

      loop do
        @iterations += 1
        break if @iterations > MAX_ITERATIONS
        break if @total_tokens > MAX_TOKENS_BUDGET

        # Claude APIをツール定義付きで呼び出し
        response = @claude.messages_with_tools(
          messages: messages,
          system: system_prompt,
          tools: @tools.map(&:definition),
          max_tokens: 4096
        )

        @total_tokens += response.usage.total_tokens

        case response.stop_reason
        when "end_turn"
          # Claudeが完了と判断
          return extract_final_answer(response)

        when "tool_use"
          # Claudeがツールを使いたい
          tool_results = execute_tools(response)

          # 会話履歴に追加
          messages << { role: "assistant", content: response.content }
          messages << { role: "user", content: tool_results }

        when "max_tokens"
          # トークン上限、継続
          messages << { role: "assistant", content: response.content }
        end
      end

      "申し訳ございません。処理が複雑で完了できませんでした。"
    end

    private

    def load_tools
      [
        Discord::Tools::SearchMessages,
        Discord::Tools::GetChannelInfo,
        Discord::Tools::GetThreadContext,
        Discord::Tools::SearchWeb
      ]
    end

    def execute_tools(response)
      tool_uses = response.content.select { |block| block.type == "tool_use" }

      tool_uses.map do |tool_use|
        Rails.logger.info "🔧 Tool: #{tool_use.name}(#{tool_use.input})"

        tool_class = @tools.find { |t| t.definition[:name] == tool_use.name }
        result = tool_class.execute(tool_use.input)

        {
          type: "tool_result",
          tool_use_id: tool_use.id,
          content: result
        }
      rescue => e
        Rails.logger.error "Tool failed: #{e.message}"
        {
          type: "tool_result",
          tool_use_id: tool_use.id,
          content: "エラー: #{e.message}",
          is_error: true
        }
      end
    end

    def extract_final_answer(response)
      response.content
        .select { |block| block.type == "text" }
        .map(&:text)
        .join("\n")
    end
  end
end
```

### ツール定義例

```ruby
# app/services/discord/tools/search_messages.rb
module Discord
  module Tools
    class SearchMessages
      # Anthropic Tool Use API形式の定義
      def self.definition
        {
          name: "search_discord_messages",
          description: "Discordサーバー内の過去のメッセージを検索します。キーワード、時間範囲、チャンネルで絞り込めます。",
          input_schema: {
            type: "object",
            properties: {
              query: {
                type: "string",
                description: "検索キーワード（例: 'Rails', 'エラー'）"
              },
              time_range: {
                type: "string",
                enum: ["1h", "1d", "1w", "1m"],
                description: "検索する時間範囲"
              },
              channel_id: {
                type: "string",
                description: "特定のチャンネルに絞り込む（オプション）"
              },
              limit: {
                type: "integer",
                description: "最大取得件数（デフォルト: 10）",
                default: 10
              }
            },
            required: ["query"]
          }
        }
      end

      # ツールの実行
      def self.execute(input)
        bot = Discord::Bot.new(
          Rails.application.credentials.dig(:discord_app, :bot_token)
        )

        results = bot.search_messages(
          query: input["query"],
          time_range: parse_time_range(input["time_range"]),
          channel_id: input["channel_id"],
          limit: input["limit"] || 10
        )

        format_results(results)
      end

      private

      def self.parse_time_range(range)
        case range
        when "1h" then 1.hour.ago
        when "1d" then 1.day.ago
        when "1w" then 1.week.ago
        when "1m" then 1.month.ago
        else 1.day.ago
        end
      end

      def self.format_results(results)
        results.map do |msg|
          {
            author: msg.dig("author", "username"),
            content: msg["content"],
            timestamp: msg["timestamp"],
            channel: msg["channel_name"],
            url: msg["url"]
          }
        end.to_json
      end
    end
  end
end
```

### Claude.rbの拡張

```ruby
# app/services/llm/claude.rb に追加
module Llm
  class Claude < Base
    # 既存のgenerateメソッドはそのまま維持

    # ツール使用対応版の新メソッド
    def messages_with_tools(messages:, system:, tools:, max_tokens: 4096)
      params = {
        model: MODEL,
        messages: format_messages(messages),
        max_tokens: max_tokens,
        system: system
      }

      # ツール定義を追加
      params[:tools] = tools if tools.present?

      @client.messages.create(**params)
    rescue Faraday::Error => e
      Rails.logger.error("Claude API error: #{e.message}")
      raise StandardError, "Claude API request failed: #{e.message}"
    end

    private

    def format_messages(messages)
      messages.map do |msg|
        {
          role: msg[:role].to_s,
          content: msg[:content]
        }
      end
    end
  end
end
```

### Job実装

```ruby
# app/jobs/discord_agent_response_job.rb
class DiscordAgentResponseJob < ApplicationJob
  queue_as :default

  def perform(channel_id:, thread_id:, user_message:, user_name:)
    Rails.logger.info "🤖 Agent started: #{user_message}"

    # Agentループ実行
    llm = Llm::Claude.new
    agent = Llm::AgentLoop.new(llm)

    response = agent.run(
      user_message: user_message,
      system_prompt: build_system_prompt(user_name, channel_id)
    )

    # Discord返信
    send_to_discord(thread_id, response)

    Rails.logger.info "✅ Agent completed (#{agent.iterations} iterations, #{agent.total_tokens} tokens)"
  rescue StandardError => e
    Rails.logger.error "❌ Agent failed: #{e.message}"
    send_to_discord(thread_id, "申し訳ございません。エラーが発生しました。")
    raise
  end

  private

  def build_system_prompt(user_name, channel_id)
    <<~PROMPT
      あなたはTeacher TeacherのオンラインコミュニティTT村のヘルプAgentです。

      #{user_name}さんからの質問に答えてください。
      利用可能なツールを使って、必要な情報を自律的に収集してください。

      行動指針:
      - 不確かな情報は推測せず、ツールで確認する
      - 複数の情報源を確認して総合的に判断する
      - 検索結果が不十分なら、条件を変えて再検索する
      - 過去の議論を参照する際は、誰がいつ発言したか明記する
      - 情報が不足している場合は、追加質問をする

      回答スタイル:
      - 簡潔で分かりやすい日本語
      - 根拠を示しながら説明
      - 必要に応じて具体例を挙げる
    PROMPT
  end

  def send_to_discord(thread_id, message)
    bot = Discord::Bot.new(
      Rails.application.credentials.dig(:discord_app, :bot_token)
    )
    bot.send_message(
      channel_or_thread_id: thread_id,
      content: message
    )
  end
end
```

## 実装の利点

### 1. フル・コントロール
- Agentの挙動を完全に制御
- デバッグが容易
- カスタマイズが自由

### 2. Rails統合
- ActiveJobで非同期実行
- Redisでキューイング
- エラー処理やリトライが標準機能で可能

### 3. Discord最適化
- Discord専用のツールを自由に追加
- コミュニティの文脈を考慮した設計
- TT村の特性に合わせた調整が可能

### 4. コスト管理
- トークン数を追跡
- 反復回数の上限設定
- 必要に応じて最適化

### 5. 学習機会
- Agent実装の深い理解
- Anthropic APIの活用方法習得
- プロダクション品質のコード設計

## 実装ロードマップ

### Phase 1: 基礎実装 ✅ **完了 (2025-10-20)**
- [x] `Llm::Claude#messages_with_tools` 実装
- [x] `Llm::AgentLoop` 実装
- [x] 基本ツール実装
  - [x] `Discord::Tools::SearchMessages` (新Guild Search API使用)
  - [x] `Discord::Tools::GetThreadContext`
  - [x] `Discord::Tools::GetChannelInfo`
  - [x] `Discord::Tools::GetMessagesAround` (前後の会話取得)
- [x] `DiscordLlmResponseJob` をAgentLoopベースに置き換え
- [x] 基本的なエラーハンドリング
- [x] 依存性注入による疎結合設計
- [x] 統合テスト完了

**実装のハイライト:**
- Guild Search API統合により検索速度100倍以上改善
- `search_messages_in_server2` で197件の検索結果（旧APIでは3件）
- `get_messages_around` で質問と回答のペアを発見可能
- フレームワーク非依存（lib配下のコードはRails依存なし）

### Phase 2: ツール拡充と認可強化 🚧 **進行中**
- [x] カテゴリベース認可実装 ✅ **完了 (2025-10-20)**
  - AgentLoopに`allowed_category_id`パラメータ追加
  - SearchMessagesでカテゴリ内チャンネル・フォーラムのみ検索
  - GetMessagesAroundでカテゴリ外チャンネルへのアクセス拒否
  - フォーラム検索バグ修正（スレッドIDではなくフォーラムチャンネルID使用）
- [x] Discord mention/link formatting ✅ **完了 (2025-10-20)**
  - `Discord::Formatter`モジュール作成
  - ユーザーメンション（`<@USER_ID>`）
  - チャンネルメンション（`<#CHANNEL_ID>`）
  - メッセージリンク（クリック可能URL）
  - 全ツールでフォーマッター使用
  - System promptでClaudeにメンション・リンク活用を指示
- [ ] チャンネル・スレッド一覧取得ツール
- [ ] Web検索ツール追加
- [ ] ユーザー情報取得ツール
- [ ] リアクション分析ツール
- [ ] ツール実行結果のキャッシュ
- [ ] プログレス表示の改善（Discord リアクション）

### Phase 3: 最適化 📋 **未着手**
- [ ] コンテキスト管理(要約・刈り込み)
- [ ] Prompt Caching活用
- [ ] Extended Thinking mode
- [ ] パフォーマンス測定と改善
- [ ] コスト追跡ダッシュボード

### Phase 4: 高度な機能 📋 **未着手**
- [ ] サブAgentの生成
- [ ] フィードバックからの学習
- [ ] 外部API統合(Stack Overflow等)
- [ ] マルチモーダル対応(画像解析)

## 期待される動作例

### ケース1: 実際の動作例 - ChatGPT関連の会話検索 ✅

**ユーザー**: 「このコミュニティで、ChatGPTについての会話ってありますかね？参考にしたくて」

**Agentの実際の動作** (2025-10-20テスト結果):
```
1. 🔧 search_discord_messages(query="ChatGPT", limit=10)
2. 👀 168件の検索結果を発見
3. 🤔 主要なトピックを整理
4. ✅ 回答生成:
   - 不登校アドバイザーAIの活用（2025年9月24日）
   - GeminiのGemとChatGPTのGPTs比較（2025年9月25日）
   - ChatGPTの基礎知識講座（2025年8月8日）
   - 「詳細が知りたければ前後の会話を調べることができますよ」と提案
```

**処理時間**: 約15秒
**イテレーション**: 2回
**トークン**: 約7,000

### ケース2: 実際の動作例 - 最近の勉強会について ✅

**ユーザー**: 「最近の勉強会について教えて」

**Agentの実際の動作** (2025-10-20テスト結果):
```
1. 🔧 search_discord_messages(query="勉強会", limit=10)
2. 👀 310件の検索結果から関連情報を抽出
3. 🤔 第2回、第3回の開催情報を整理
4. ✅ 回答生成:
   - 子どもの伴走勉強会シリーズの詳細
   - 開催日時、テーマ、内容
   - アーカイブ動画の存在を案内
```

**処理時間**: 約25秒
**イテレーション**: 4回
**トークン**: 約14,000

### ケース3: get_messages_around活用 - 質問と回答のペア発見 🚧

**ユーザー**: 「TTのチラシのデータはどこにありますか？」

**期待される動作** (現在開発中):
```
1. 🔧 search_discord_messages(query="チラシ どこ")
2. 👀 yamaryysさんの質問を発見（「どこから探すのかわからなくなる」）
3. 🔧 get_messages_around(channel_id="...", message_id="...", limit=10)
4. 👀 chimachimapanさんの回答を発見（Google DriveのURL）
5. ✅ 「チラシはこちらにあります: https://drive.google.com/...」
```

**課題**: エージェントが適切なキーワード（「どこから探す」）を思いつく必要がある
**改善案**: チャンネル一覧ツールで関連チャンネルを探索

## 注意点とベストプラクティス

### 安全装置
- **最大反復回数**: 10-15回(無限ループ防止)
- **タイムアウト**: 60-90秒
- **トークン上限**: 50,000トークン/リクエスト
- **レート制限**: Discord API、Anthropic APIの制限を遵守

### ツール設計
- **単一責任**: 1ツール = 1機能
- **明確な説明**: Claudeが判断できる詳細なdescription
- **エラー処理**: 失敗時もClaudeに返して再試行可能に
- **冪等性**: 同じ呼び出しで同じ結果
- **高速化**: できるだけ軽量に

### コンテキスト管理
- **スライディングウィンドウ**: 直近2-3ターンのみ保持
- **要約**: 長い会話は定期的に要約
- **重要情報**: ユーザーの最初の質問は常に保持

### ユーザー体験
- **プログレス表示**: 「考え中」リアクション
- **タイムアウト通知**: 処理が長引く場合は中間報告
- **エラー時のフォールバック**: シンプルモードへ降格

## 参考資料

### 公式ドキュメント
- [Anthropic Tool Use Documentation](https://docs.anthropic.com/claude/docs/tool-use)
- [Building agents with the Claude Agent SDK](https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk)
- [Model Context Protocol (MCP)](https://modelcontextprotocol.io/)

### Agent SDK
- [Claude Agent SDK (Python)](https://github.com/anthropics/claude-agent-sdk-python)
- [Claude Agent SDK (TypeScript)](https://github.com/anthropics/claude-agent-sdk-typescript)
- [Claude Code SDK Demos](https://github.com/anthropics/claude-code-sdk-demos)

### その他のフレームワーク
- [Claude Code GitHub](https://github.com/anthropics/claude-code)
- [LangChain Agent Documentation](https://python.langchain.com/docs/modules/agents/)

## まとめ

### 3つの選択肢の比較

| 項目 | 選択肢1: CLI包む | 選択肢2: Agent SDK | 選択肢3: 自前実装 |
|-----|----------------|-------------------|-----------------|
| 言語 | Ruby(subprocess) | Python/TypeScript | Ruby |
| Agent loop | CLI内部 | SDK内部 | 自分で実装 |
| ツール追加 | 困難 | Python/TS関数 | Ruby class |
| Rails統合 | 複雑 | 複雑(多言語) | ネイティブ |
| 保守性 | 低 | 中 | 高 |
| 学習曲線 | 低 | 中 | 高 |
| カスタマイズ | 低 | 中 | 高 |
| 公式サポート | なし | あり | なし |
| 推奨度 | ❌ | 🤔 | ⭐️ |

### このプロジェクトでの結論

**選択肢3(自前実装)を推奨**する理由:

✅ **同じ技術**: LLM (Claude Sonnet 4.5) / API (Anthropic Tool Use) / パターン (Agentic Loop)
✅ **Rails統合**: ネイティブRuby実装で保守性が高い
✅ **Discord最適化**: Discord専用ツールを自由に設計可能
✅ **学習機会**: Agent実装の深い理解が得られる
✅ **シンプル**: Agentループ自体は100行程度

難しいのはツール設計とプロンプト調整で、**これはどの選択肢でも必要な作業**。

### Agent SDKを検討すべきケース

以下の場合は選択肢2(Agent SDK)も検討価値あり:

- Python/TypeScriptの導入に抵抗がない
- 大規模で複雑なAgent機能が必要
- 公式サポートとアップデートが重要
- Claude Codeの高度な機能(コード生成等)を活用したい
- チームにPython/TypeScriptの経験者がいる

---

## 実装完了状況 (2025-10-20更新)

### ✅ 完成した機能

#### 1. コア実装
- **`Llm::AgentLoop`**: 自律的なAgent loop実装（100行程度）
- **`Llm::Claude#messages_with_tools`**: Anthropic Tool Use API対応
- **依存性注入**: lib配下はRails非依存、テスタブルな設計

#### 2. Discord API統合
- **Guild Search API** (`search_messages_in_server2`):
  - 旧APIより100倍以上高速（60秒 → 0.4秒）
  - 検索精度大幅向上（3件 → 197件）
  - `URI.encode_www_form_component`使用（CGI.escape非推奨対応）
- **Messages Around API** (`get_messages_around`):
  - 特定メッセージの前後を取得（1-100件）
  - 質問と回答のペアを発見可能

#### 3. Discord Tools (4種類)
| ツール | 機能 | 状態 |
|--------|------|------|
| `SearchMessages` | 新Guild Search API使用、サーバー全体を高速検索、カテゴリ認可対応 | ✅ |
| `GetChannelInfo` | チャンネル情報取得、チャンネルメンション表示 | ✅ |
| `GetThreadContext` | スレッドの会話履歴取得、ユーザーメンション表示 | ✅ |
| `GetMessagesAround` | 特定メッセージの前後取得、カテゴリ認可対応 | ✅ |

#### 4. Job統合
- **`DiscordLlmResponseJob`**: AgentLoopベースに完全書き換え
  - 旧実装（シングルショット + 手動検索）から移行
  - エージェントが自律的にツール選択・実行
  - 統合テスト完了、実動作確認済み

### 📊 パフォーマンス実績

**テストケース: ChatGPT会話検索**
- 検索結果: 168件発見
- 処理時間: 15秒
- イテレーション: 2回
- トークン: 7,000

**テストケース: 勉強会情報**
- 検索結果: 310件から情報抽出
- 処理時間: 25秒
- イテレーション: 4回
- トークン: 14,000

### ✅ 最近追加された機能 (2025-10-20)

#### カテゴリベース認可
一般メンバーが管理者用情報にアクセスできないよう、カテゴリ単位で検索範囲を制限:

```ruby
# DiscordLlmResponseJobで取得したカテゴリIDをAgentLoopに渡す
category_id = discord_bot.get_channel_category(channel_id)
agent = Llm::AgentLoop.new(
  claude,
  discord_bot: discord_bot,
  allowed_category_id: category_id
)
```

- SearchMessages: カテゴリ内のテキストチャンネル + フォーラムチャンネルのみ検索
- GetMessagesAround: カテゴリ外チャンネルへのアクセス拒否
- フォーラム検索の重要な修正: フォーラムチャンネルID（type: 15）を渡すと、その中のすべてのスレッドを自動検索

**テスト結果:**
- カテゴリID `1168552463050231911` で「明太子」を検索
- フォーラム「村の掲示板」内のスレッドから正しく検索
- やまやの明太子、ふるさと納税の話題を発見
- 処理時間: 12.61秒

#### Discord mention/link formatting
ボット応答に含まれるユーザー名やチャンネル名をクリック可能に:

**実装:**
- `Discord::Formatter`モジュール: `mention_user`, `mention_channel`, `message_link`, `display_name`
- 全ツール（SearchMessages, GetMessagesAround, GetThreadContext, GetChannelInfo）でフォーマッター使用
- System promptでClaudeに指示: 検索結果のメンションとリンクをそのまま引用

**効果:**
```
# Before (プレーンテキスト):
ユーザー名さんが明太子について語っていました

# After (クリック可能):
<@USER_ID>さんが[こちらのメッセージ](https://discord.com/channels/.../...)で明太子について語っていました
```

- ユーザーメンション: クリックでプロフィール表示
- チャンネルメンション: クリックでチャンネル移動
- メッセージリンク: クリックで元の会話に直接ジャンプ

### 🚧 現在の課題

1. **検索キーワード選択**: エージェントが最適なキーワードを思いつけない場合がある
   - 例: 「TTのチラシ」で検索しても「どこから探す」というキーワードには辿り着けない
   - 改善案: チャンネル一覧ツールで関連チャンネルを探索

2. **プロンプトチューニング**: システムプロンプトの最適化が継続的に必要
   - リトライロジックの調整
   - ツール使用方針の明確化

3. **プログレス表示**: 長時間処理でユーザーが待つ間、何が起きているか不明
   - 改善案: 「Discordを◯◯で検索します」などの進捗メッセージ

### 🎯 次のステップ

**Phase 2の残りタスク:**
1. プログレス表示改善（Discordリアクションまたはメッセージ）
2. スレッド内コンテキスト活用（スレッド内の直前発言を考慮）
3. チャンネル・スレッド一覧取得ツール実装
4. より複雑な質問でのテストとプロンプト改善
