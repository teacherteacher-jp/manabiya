# AI Agent Implementation Plan

## 現状の課題

現在の実装は「単発のLLM呼び出し」で、AI Agentとは程遠い:

```
ユーザー質問
  ↓
キーワード抽出（Claude API呼び出し1回目）
  ↓
Discord検索（1回だけ）
  ↓
回答生成（Claude API呼び出し2回目）
  ↓
終了
```

課題:
- 情報が不足していても追加で調査しない
- 検索結果が期待と違っても再試行しない
- 複雑な質問を分解して段階的に解決できない
- 自律的な判断ができない

## 目指す姿: Agentic Loop

Claude CodeやGemini CLIのように、自律的に情報を集めて回答するボット:

```
ユーザー質問
  ↓
┌─────────────────────────────┐
│ 思考: 何の情報が必要?         │
│ 判断: どのツールを使う?       │ ← Claudeが自律判断
│ 実行: ツール呼び出し          │
│ 観察: 結果を確認             │
│ 継続: まだ足りない?          │
└─────────────────────────────┘
  ↓ 十分な情報が集まるまでループ
✅ 回答生成
```

## 実装アプローチの検討

### 選択肢の概要

Agentを実装する方法として、以下の選択肢がある:

1. **既存CLIツールを包む** (Claude Code CLI / Gemini CLI)
2. **公式Agent SDKを使う** (Anthropic Claude Agent SDK)
3. **自前でAgentループを実装** (Anthropic API + 独自実装)

### ❌ 選択肢1: 既存CLIツールを包む

「Claude CodeやGemini CLIを動かして、そのインターフェイスにDiscordをかぶせる」アプローチ:

**Claude Codeの場合:**
- VSCode拡張機能として設計されている
- CLIモードも存在するが、インタラクティブな対話型で設計されている
- Discord用のカスタムツールを注入する仕組みがない
- サーバーサイドで複数リクエストを並列処理する用途には不向き

**Gemini CLIの場合:**
```ruby
# 理論上は可能だが...
response = `gemini chat "#{user_message}"`
```

問題点:
- プロセス起動のオーバーヘッド(毎リクエストでプロセス生成)
- セッション管理不可(毎回コンテキストリセット)
- Discord専用ツールを追加できない
- エラーハンドリング困難
- セキュリティリスク(コマンドインジェクション)
- インタラクティブなCLIツールをバッチ処理的に使うのは本来の用途と異なる

### 🤔 選択肢2: 公式Agent SDKを使う

AnthropicがPythonとTypeScript向けに提供している **Claude Agent SDK** を使うアプローチ:

- GitHub: [claude-agent-sdk-python](https://github.com/anthropics/claude-agent-sdk-python)
- GitHub: [claude-agent-sdk-typescript](https://github.com/anthropics/claude-agent-sdk-typescript)
- 公式ブログ: [Building agents with the Claude Agent SDK](https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk)

**主な機能:**
- `ClaudeSDKClient`: Claude Codeとの双方向インタラクティブな会話
- カスタムツール: Pythonの関数としてツールを定義可能(in-process MCP servers)
- フック機能: Agent loopの特定のタイミングで処理を挟める
- Claude Codeの既存Agent機能をラップ

**メリット:**
- 公式サポート、バグ修正やアップデートが期待できる
- Agent loopの実装が不要(Claude Codeの機能を利用)
- in-process MCP serverでツールをPython/TSで直接定義
- ドキュメントとサンプルコードが充実

**デメリット:**
- **言語の制約**: Python または TypeScript のみ(Rubyサポートなし)
- **Claude Codeへの依存**: Claude Codeのインストールと実行環境が必要
- **アーキテクチャの複雑化**: Rails(Ruby) → Python/Node.js → Claude Code の多層構造
- **デプロイの複雑化**: Railsアプリに加えてPython/Node.js環境の管理
- **オーバーヘッド**: Claude Codeプロセスを起動・管理する必要がある
- **カスタマイズの制約**: Claude Codeの枠組みの中での実装になる

**Rails統合の場合:**
```ruby
# RailsからPython SDKを呼び出す必要がある
class DiscordAgentResponseJob < ApplicationJob
  def perform(message)
    # 方法1: Python subprocessを起動
    result = `python3 agent_script.py "#{message}"`

    # 方法2: gRPC/HTTPでPythonサービスと通信
    response = AgentService.call(message)
  end
end
```

**判断:**
- RailsネイティブなプロジェクトでPython/TypeScriptを導入するのは、保守性の観点から慎重に検討すべき
- 小規模チームや学習目的のプロジェクトでは、依存関係を増やすより自前実装の方が理解しやすい
- ただし、大規模で複雑なAgent機能が必要な場合は検討の価値あり

### ⭐️ 選択肢3: 自前でAgentループ実装(推奨)

Claude CodeやGemini CLIと**同じ技術**を使って自作:

| 要素 | Claude Code | 自作実装 | 状況 |
|-----|------------|---------|------|
| LLM | Claude Sonnet 4.5 | Claude Sonnet 4.5 | ✅ 同じ |
| API | Anthropic Tool Use | Anthropic Tool Use | ✅ 同じ |
| ツール | ファイル操作等 | Discord操作 | ✅ より適切 |
| Agentループ | VSCode拡張内 | Ruby実装 | 🔨 実装必要 |
| 統合 | VSCode | Rails | ✅ ネイティブ |

**結論**: Claude Codeは「Anthropic APIの参考実装」に過ぎない。同じAPIを使えば同等の知能が得られる。

## 実装方針

### アーキテクチャ

```
Discord Message
  ↓
DiscordAgentResponseJob (Rails ActiveJob)
  ↓
Llm::AgentLoop (Agentループオーケストレーター)
  ↓
Llm::Claude (Anthropic SDK wrapper, ツール対応版)
  ↓
Discord::Tools::* (各種ツール実装)
  ├─ SearchMessages (Discord検索)
  ├─ GetChannelInfo (チャンネル情報)
  ├─ GetThreadContext (スレッド履歴)
  ├─ SearchWeb (外部検索)
  └─ AnalyzeReactions (リアクション分析)
```

### コア実装: Agentループ

```ruby
# app/services/llm/agent_loop.rb
module Llm
  class AgentLoop
    MAX_ITERATIONS = 10
    MAX_TOKENS_BUDGET = 50_000

    attr_reader :iterations, :total_tokens

    def initialize(claude_client)
      @claude = claude_client
      @tools = load_tools
      @iterations = 0
      @total_tokens = 0
    end

    def run(user_message:, system_prompt:)
      messages = [{ role: "user", content: user_message }]

      loop do
        @iterations += 1
        break if @iterations > MAX_ITERATIONS
        break if @total_tokens > MAX_TOKENS_BUDGET

        # Claude APIをツール定義付きで呼び出し
        response = @claude.messages_with_tools(
          messages: messages,
          system: system_prompt,
          tools: @tools.map(&:definition),
          max_tokens: 4096
        )

        @total_tokens += response.usage.total_tokens

        case response.stop_reason
        when "end_turn"
          # Claudeが完了と判断
          return extract_final_answer(response)

        when "tool_use"
          # Claudeがツールを使いたい
          tool_results = execute_tools(response)

          # 会話履歴に追加
          messages << { role: "assistant", content: response.content }
          messages << { role: "user", content: tool_results }

        when "max_tokens"
          # トークン上限、継続
          messages << { role: "assistant", content: response.content }
        end
      end

      "申し訳ございません。処理が複雑で完了できませんでした。"
    end

    private

    def load_tools
      [
        Discord::Tools::SearchMessages,
        Discord::Tools::GetChannelInfo,
        Discord::Tools::GetThreadContext,
        Discord::Tools::SearchWeb
      ]
    end

    def execute_tools(response)
      tool_uses = response.content.select { |block| block.type == "tool_use" }

      tool_uses.map do |tool_use|
        Rails.logger.info "🔧 Tool: #{tool_use.name}(#{tool_use.input})"

        tool_class = @tools.find { |t| t.definition[:name] == tool_use.name }
        result = tool_class.execute(tool_use.input)

        {
          type: "tool_result",
          tool_use_id: tool_use.id,
          content: result
        }
      rescue => e
        Rails.logger.error "Tool failed: #{e.message}"
        {
          type: "tool_result",
          tool_use_id: tool_use.id,
          content: "エラー: #{e.message}",
          is_error: true
        }
      end
    end

    def extract_final_answer(response)
      response.content
        .select { |block| block.type == "text" }
        .map(&:text)
        .join("\n")
    end
  end
end
```

### ツール定義例

```ruby
# app/services/discord/tools/search_messages.rb
module Discord
  module Tools
    class SearchMessages
      # Anthropic Tool Use API形式の定義
      def self.definition
        {
          name: "search_discord_messages",
          description: "Discordサーバー内の過去のメッセージを検索します。キーワード、時間範囲、チャンネルで絞り込めます。",
          input_schema: {
            type: "object",
            properties: {
              query: {
                type: "string",
                description: "検索キーワード（例: 'Rails', 'エラー'）"
              },
              time_range: {
                type: "string",
                enum: ["1h", "1d", "1w", "1m"],
                description: "検索する時間範囲"
              },
              channel_id: {
                type: "string",
                description: "特定のチャンネルに絞り込む（オプション）"
              },
              limit: {
                type: "integer",
                description: "最大取得件数（デフォルト: 10）",
                default: 10
              }
            },
            required: ["query"]
          }
        }
      end

      # ツールの実行
      def self.execute(input)
        bot = Discord::Bot.new(
          Rails.application.credentials.dig(:discord_app, :bot_token)
        )

        results = bot.search_messages(
          query: input["query"],
          time_range: parse_time_range(input["time_range"]),
          channel_id: input["channel_id"],
          limit: input["limit"] || 10
        )

        format_results(results)
      end

      private

      def self.parse_time_range(range)
        case range
        when "1h" then 1.hour.ago
        when "1d" then 1.day.ago
        when "1w" then 1.week.ago
        when "1m" then 1.month.ago
        else 1.day.ago
        end
      end

      def self.format_results(results)
        results.map do |msg|
          {
            author: msg.dig("author", "username"),
            content: msg["content"],
            timestamp: msg["timestamp"],
            channel: msg["channel_name"],
            url: msg["url"]
          }
        end.to_json
      end
    end
  end
end
```

### Claude.rbの拡張

```ruby
# app/services/llm/claude.rb に追加
module Llm
  class Claude < Base
    # 既存のgenerateメソッドはそのまま維持

    # ツール使用対応版の新メソッド
    def messages_with_tools(messages:, system:, tools:, max_tokens: 4096)
      params = {
        model: MODEL,
        messages: format_messages(messages),
        max_tokens: max_tokens,
        system: system
      }

      # ツール定義を追加
      params[:tools] = tools if tools.present?

      @client.messages.create(**params)
    rescue Faraday::Error => e
      Rails.logger.error("Claude API error: #{e.message}")
      raise StandardError, "Claude API request failed: #{e.message}"
    end

    private

    def format_messages(messages)
      messages.map do |msg|
        {
          role: msg[:role].to_s,
          content: msg[:content]
        }
      end
    end
  end
end
```

### Job実装

```ruby
# app/jobs/discord_agent_response_job.rb
class DiscordAgentResponseJob < ApplicationJob
  queue_as :default

  def perform(channel_id:, thread_id:, user_message:, user_name:)
    Rails.logger.info "🤖 Agent started: #{user_message}"

    # Agentループ実行
    llm = Llm::Claude.new
    agent = Llm::AgentLoop.new(llm)

    response = agent.run(
      user_message: user_message,
      system_prompt: build_system_prompt(user_name, channel_id)
    )

    # Discord返信
    send_to_discord(thread_id, response)

    Rails.logger.info "✅ Agent completed (#{agent.iterations} iterations, #{agent.total_tokens} tokens)"
  rescue StandardError => e
    Rails.logger.error "❌ Agent failed: #{e.message}"
    send_to_discord(thread_id, "申し訳ございません。エラーが発生しました。")
    raise
  end

  private

  def build_system_prompt(user_name, channel_id)
    <<~PROMPT
      あなたはTeacher TeacherのオンラインコミュニティTT村のヘルプAgentです。

      #{user_name}さんからの質問に答えてください。
      利用可能なツールを使って、必要な情報を自律的に収集してください。

      行動指針:
      - 不確かな情報は推測せず、ツールで確認する
      - 複数の情報源を確認して総合的に判断する
      - 検索結果が不十分なら、条件を変えて再検索する
      - 過去の議論を参照する際は、誰がいつ発言したか明記する
      - 情報が不足している場合は、追加質問をする

      回答スタイル:
      - 簡潔で分かりやすい日本語
      - 根拠を示しながら説明
      - 必要に応じて具体例を挙げる
    PROMPT
  end

  def send_to_discord(thread_id, message)
    bot = Discord::Bot.new(
      Rails.application.credentials.dig(:discord_app, :bot_token)
    )
    bot.send_message(
      channel_or_thread_id: thread_id,
      content: message
    )
  end
end
```

## 実装の利点

### 1. フル・コントロール
- Agentの挙動を完全に制御
- デバッグが容易
- カスタマイズが自由

### 2. Rails統合
- ActiveJobで非同期実行
- Redisでキューイング
- エラー処理やリトライが標準機能で可能

### 3. Discord最適化
- Discord専用のツールを自由に追加
- コミュニティの文脈を考慮した設計
- TT村の特性に合わせた調整が可能

### 4. コスト管理
- トークン数を追跡
- 反復回数の上限設定
- 必要に応じて最適化

### 5. 学習機会
- Agent実装の深い理解
- Anthropic APIの活用方法習得
- プロダクション品質のコード設計

## 実装ロードマップ

### Phase 1: 基礎実装 (2-3日)
- [ ] `Llm::Claude#messages_with_tools` 実装
- [ ] `Llm::AgentLoop` 実装
- [ ] 基本ツール2-3個実装
  - [ ] `Discord::Tools::SearchMessages`
  - [ ] `Discord::Tools::GetThreadContext`
  - [ ] `Discord::Tools::GetChannelInfo`
- [ ] `DiscordAgentResponseJob` に置き換え
- [ ] 基本的なエラーハンドリング

### Phase 2: ツール拡充 (2-3日)
- [ ] Web検索ツール追加
- [ ] ユーザー情報取得ツール
- [ ] リアクション分析ツール
- [ ] ツール実行結果のキャッシュ
- [ ] プログレス表示の改善

### Phase 3: 最適化 (2-3日)
- [ ] コンテキスト管理(要約・刈り込み)
- [ ] Prompt Caching活用
- [ ] Extended Thinking mode
- [ ] パフォーマンス測定と改善
- [ ] コスト追跡ダッシュボード

### Phase 4: 高度な機能 (継続的)
- [ ] サブAgentの生成
- [ ] フィードバックからの学習
- [ ] 外部API統合(Stack Overflow等)
- [ ] マルチモーダル対応(画像解析)

## 期待される動作例

### ケース1: 複雑な質問

**ユーザー**: 「先週のRailsの議論で誰が何を言ってた?」

**Agentの思考プロセス**:
```
1. 🤔 「先週」「Rails」に関する議論を探す必要がある
2. 🔧 search_discord_messages(query="Rails", time_range="1w")
3. 👀 5件のメッセージが見つかった
4. 🤔 発言者の情報も欲しい
5. 🔧 get_user_activity(user_ids=["123", "456"])
6. 👀 ユーザー情報取得完了
7. ✅ 情報が揃った、回答を生成
```

### ケース2: 情報不足の場合

**ユーザー**: 「デプロイエラーについて教えて」

**Agentの思考プロセス**:
```
1. 🤔 「デプロイエラー」で検索してみる
2. 🔧 search_discord_messages(query="デプロイエラー", time_range="1d")
3. 👀 結果が0件...
4. 🤔 時間範囲を広げてみよう
5. 🔧 search_discord_messages(query="デプロイ", time_range="1w")
6. 👀 3件見つかった
7. 🤔 でも「エラー」について具体的な情報がない
8. ✅ 「デプロイに関する議論は見つかりましたが、エラーについては
      具体的にどんな問題が起きているか教えていただけますか?」
```

## 注意点とベストプラクティス

### 安全装置
- **最大反復回数**: 10-15回(無限ループ防止)
- **タイムアウト**: 60-90秒
- **トークン上限**: 50,000トークン/リクエスト
- **レート制限**: Discord API、Anthropic APIの制限を遵守

### ツール設計
- **単一責任**: 1ツール = 1機能
- **明確な説明**: Claudeが判断できる詳細なdescription
- **エラー処理**: 失敗時もClaudeに返して再試行可能に
- **冪等性**: 同じ呼び出しで同じ結果
- **高速化**: できるだけ軽量に

### コンテキスト管理
- **スライディングウィンドウ**: 直近2-3ターンのみ保持
- **要約**: 長い会話は定期的に要約
- **重要情報**: ユーザーの最初の質問は常に保持

### ユーザー体験
- **プログレス表示**: 「考え中」リアクション
- **タイムアウト通知**: 処理が長引く場合は中間報告
- **エラー時のフォールバック**: シンプルモードへ降格

## 参考資料

### 公式ドキュメント
- [Anthropic Tool Use Documentation](https://docs.anthropic.com/claude/docs/tool-use)
- [Building agents with the Claude Agent SDK](https://www.anthropic.com/engineering/building-agents-with-the-claude-agent-sdk)
- [Model Context Protocol (MCP)](https://modelcontextprotocol.io/)

### Agent SDK
- [Claude Agent SDK (Python)](https://github.com/anthropics/claude-agent-sdk-python)
- [Claude Agent SDK (TypeScript)](https://github.com/anthropics/claude-agent-sdk-typescript)
- [Claude Code SDK Demos](https://github.com/anthropics/claude-code-sdk-demos)

### その他のフレームワーク
- [Claude Code GitHub](https://github.com/anthropics/claude-code)
- [LangChain Agent Documentation](https://python.langchain.com/docs/modules/agents/)

## まとめ

### 3つの選択肢の比較

| 項目 | 選択肢1: CLI包む | 選択肢2: Agent SDK | 選択肢3: 自前実装 |
|-----|----------------|-------------------|-----------------|
| 言語 | Ruby(subprocess) | Python/TypeScript | Ruby |
| Agent loop | CLI内部 | SDK内部 | 自分で実装 |
| ツール追加 | 困難 | Python/TS関数 | Ruby class |
| Rails統合 | 複雑 | 複雑(多言語) | ネイティブ |
| 保守性 | 低 | 中 | 高 |
| 学習曲線 | 低 | 中 | 高 |
| カスタマイズ | 低 | 中 | 高 |
| 公式サポート | なし | あり | なし |
| 推奨度 | ❌ | 🤔 | ⭐️ |

### このプロジェクトでの結論

**選択肢3(自前実装)を推奨**する理由:

✅ **同じ技術**: LLM (Claude Sonnet 4.5) / API (Anthropic Tool Use) / パターン (Agentic Loop)
✅ **Rails統合**: ネイティブRuby実装で保守性が高い
✅ **Discord最適化**: Discord専用ツールを自由に設計可能
✅ **学習機会**: Agent実装の深い理解が得られる
✅ **シンプル**: Agentループ自体は100行程度

難しいのはツール設計とプロンプト調整で、**これはどの選択肢でも必要な作業**。

### Agent SDKを検討すべきケース

以下の場合は選択肢2(Agent SDK)も検討価値あり:

- Python/TypeScriptの導入に抵抗がない
- 大規模で複雑なAgent機能が必要
- 公式サポートとアップデートが重要
- Claude Codeの高度な機能(コード生成等)を活用したい
- チームにPython/TypeScriptの経験者がいる
